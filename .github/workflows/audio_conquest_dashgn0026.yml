name: Audio Conquest dashgn0026

on:
  workflow_dispatch:
    inputs:
      chunk_size:
        description: 'Tracks per worker'
        default: '5000'
        type: string
      start_offset:
        description: 'Starting offset (worker 0)'
        default: '0'
        type: string

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 350
    strategy:
      fail-fast: false
      matrix:
        worker: [0, 1, 2]
    steps:
      - name: Setup
        run: |
          OFFSET=$(( ${{ inputs.start_offset }} + ${{ matrix.worker }} * ${{ inputs.chunk_size }} ))
          echo "Conquest dashgn0026 Worker ${{ matrix.worker }}: offset=$OFFSET, limit=${{ inputs.chunk_size }}"
          sudo apt-get update && sudo apt-get install -y ffmpeg
          curl -fsSL https://deno.land/install.sh | sh
          export DENO_INSTALL="$HOME/.deno"
          export PATH="$DENO_INSTALL/bin:$PATH"
          echo "$DENO_INSTALL/bin" >> $GITHUB_PATH
          sudo curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp
          sudo chmod a+rx /usr/local/bin/yt-dlp
          pip install boto3 requests
          echo "IyBOZXRzY2FwZSBIVFRQIENvb2tpZSBGaWxlCiMgaHR0cHM6Ly9jdXJsLmhheHguc2UvcmZjL2Nvb2tpZV9zcGVjLmh0bWwKIyBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUhIERvIG5vdCBlZGl0LgoKLnlvdXR1YmUuY29tCVRSVUUJLwlGQUxTRQkxODAyMDg4NDY3CVNJRAlnLmEwMDA1UWkxMm1UTGZxV0xqRzBGd1B3akNXT2dDSTZTNmFsMGx6R1gtbDBPcFV3a1dva2R0a090NXBRWFZpUWFkaFZqd0xvdEZnQUNnWUtBVUVTQVE4U0ZRSEdYMk1pWVVKeFFHd2RmMmQzNmVKODZtTG5heG9WQVVGOHlLb3c4X3A5TWlWSTg3c0VpQ0M0ODFZWDAwNzYKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDIwODg0NjcJX19TZWN1cmUtMVBTSUQJZy5hMDAwNVFpMTJtVExmcVdMakcwRndQd2pDV09nQ0k2UzZhbDBsekdYLWwwT3BVd2tXb2tkRzJ3RV9sN0dybFF0ejRLTnJMQXJ5d0FDZ1lLQVNZU0FROFNGUUhHWDJNaUNTZkFTOWVJajF3TDBYNVNhaW4tZFJvVkFVRjh5S3JxS0xXZWd0bjc3Qk1EdzcyYzBjVjIwMDc2Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyMDg4NDY3CV9fU2VjdXJlLTNQU0lECWcuYTAwMDVRaTEybVRMZnFXTGpHMEZ3UHdqQ1dPZ0NJNlM2YWwwbHpHWC1sME9wVXdrV29rZE1KcXdhS2p1eklEMVVsUTRNVC03OGdBQ2dZS0FjZ1NBUThTRlFIR1gyTWkzc2JLN05WbE1TdTNnYmRpSTJ5SW9Sb1ZBVUY4eUtwazVjUUJlbDdsUDJKQU5EcWVCNWVfMDA3NgoueW91dHViZS5jb20JVFJVRQkvCUZBTFNFCTE4MDIwODg0NjcJSFNJRAlBU2lNNUpPMW5OU1loRnBDUwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjA4ODQ2NwlTU0lECUEtUXg2amh1RjlCMkZ6eDgxCi55b3V0dWJlLmNvbQlUUlVFCS8JRkFMU0UJMTgwMjA4ODQ2NwlBUElTSUQJNmQxemlRakxHYU5sdFpINC9BSDhrVnlPZDJYeVZLUEI4UwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjA4ODQ2NwlTQVBJU0lECVhVbXY1LXYyeUtSWG1EX1UvQXRsQkZZZ29HU3Y1SkhEZHoKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDIwODg0NjcJX19TZWN1cmUtMVBBUElTSUQJWFVtdjUtdjJ5S1JYbURfVS9BdGxCRllnb0dTdjVKSERkegoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjA4ODQ2NwlfX1NlY3VyZS0zUEFQSVNJRAlYVW12NS12MnlLUlhtRF9VL0F0bEJGWWdvR1N2NUpIRGR6Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyMDg4NDgyCUxPR0lOX0lORk8JQUZtbUYyc3dSUUlnWUFmUkhaQWJsR25maHFGTVFmQ3JrMWE1cXVHamhtRzkxVHFDOVhvRFIyVUNJUUMzSXlubEM3b2gtYndSY0h6cXRXQWh4VGw3d3ZkVTFiWnBlTndRbFV6YjVROlFVUTNNak5tZUdwcWIyRnRhR0paUmpKTWNXdEdUVFJFZGpsNVRsUkZZblJyUzJsTFF6bGFRVzkwZDAxQ2FsRlpWVmxLVmxCbVMxZGlSSFpHYlVScVIyUkVVV1ptVURCMk4xSnNkSGxoWm1WMmFHUlpSemhMTkZoc1NWUlpja2xYTW5aclJuWjVXVEpDZFd4cVVYZDZSMGRpUkZsd1dtNXRURU5WTURSTmQzbEVXRnB3TFVsNlEyMXBlSFJrTjNsRFptNVpYelJpVlhNM2QxTjNNRzlpVVZKMwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc5OTA2NDQ4NQlfX1NlY3VyZS0xUFNJRFRTCXNpZHRzLUNqRUJmbGFDZFJEYlZrN0t6aERBMVF6NS0zQnpIOHhIMk5IaDZyTlNESWg0TDFmai1uQnQ4MWUtZkNucC11Y0Y1NUlURUFBCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5MDY0NDg1CV9fU2VjdXJlLTNQU0lEVFMJc2lkdHMtQ2pFQmZsYUNkUkRiVms3S3poREExUXo1LTNCekg4eEgyTkhoNnJOU0RJaDRMMWZqLW5CdDgxZS1mQ25wLXVjRjU1SVRFQUEKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDIwODkwMzAJUFJFRglmND00MDAwMDAwJmY2PTQwMDAwMDAwJnR6PUFzaWEuS3VhbGFfTHVtcHVyJmY3PTEwMAoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc2NzUyOTExMwlDT05TSVNURU5DWQlBUGVWeWlfbTFyN1diSm1xZmNWRVNKc0FTY2M3TzFBVXNCUkJBOWhZdUxHSlJBWC1ycGlDR2ItMld0d0d4SjJTbkd6c21jSWtkZEE3SGE2UG8tbjRNNTNpbHF5ZENSWHRHWUxYaVNYMmE5WmFibmRpWlVZellrUHZLRFJvMEEtMTlGRW1uRFB5SHR6TGVnbkJfcEFKdW9WXwoueW91dHViZS5jb20JVFJVRQkvCUZBTFNFCTE3OTkwNjUwMzMJU0lEQ0MJQUtFeVh6VVZ1ZFUxaUNfVVhfNUd6S21qalk2dG94TEZtN3JRcWl6cnRhc1lBLTJ4YklpeTVOemw4ZVZ6b1lXU1pmNFp0TWdxCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5MDY1MDMzCV9fU2VjdXJlLTFQU0lEQ0MJQUtFeVh6VTJzQmJ1X2J2Ql9FcnhZU1hNTG1rR2hnMEZ6WXdZejk0d1MtcUZKVERSLTBkMlI4TlV3dWVxblRFR3plMEVpOV9ICi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5MDY1MDMzCV9fU2VjdXJlLTNQU0lEQ0MJQUtFeVh6VXhsaVVRQ0FVb3ExU1RKeW5QQ2ZVbC1paEk2R2ZITVNpNU1zU0U0aVlsM0pJS0lESGdsZXdUcUczNHpTQ21JM3NETXcKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTAJWVNDCXZuQi1qNW03SmJZCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzgzMDgxMDI4CVZJU0lUT1JfSU5GTzFfTElWRQl3T3gtZ1ktN0d1cwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc4MzA4MTAyOAlWSVNJVE9SX1BSSVZBQ1lfTUVUQURBVEEJQ2dKTldSSUVHZ0FnVWclM0QlM0QKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE3ODMwODA0ODIJX19TZWN1cmUtWU5JRAkxNC5ZVD1MNDRzeUI3U2RfbF9zYkI1ZHNYY0ZIcmNMOUVaUTdMTHNmR2pDay1PeG5tOS1icFdWeWQyOEZPRklkQ3ZzbG41OU9nVmRuV0prYktpVjd4LUNRY2JlVFQ4WEo3LVRkN054a25KTW53Q0x3c0pMZ05ZMmhlZDVpbUYzWUhESmF6aTNUTXFLZFFOV2hqQUdzTDJtQ2pBM0toNDQtd1ZxZm5nUmNkODY5eWhnbFFQZnVmWXVTdG5FUS1oVUFkNjVsYVlTRm0waDlQV0RHcl9VSlVjWC1wTFg0VlYyQnl0MDVXdUpkWkxLQjdyWDhJejRzb1lfMEVHcjVlVFFLeGZ1RGpPWnJkNnJUXzhCSXBYdVBaWERGcDJVRDIxb0lRYXBUQUU2ajhuSVQtOTRVZnRUYVlnSUNhUGl6dmhzN012dkNjY1VJMnpzXzFvX1dQaU4yekExMUVyaFEKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE3ODMwODA0ODIJX19TZWN1cmUtUk9MTE9VVF9UT0tFTglDTm1NcmNULW1fN05qUUVRbC1qZDJlenhrUU1ZdWNIbDJlenhrUU0lM0QK" | base64 -d > /tmp/cookies.txt

      - name: Create worker script
        run: |
          cat << 'SCRIPT' > worker.py
          import os
          import subprocess
          import time
          import random
          from pathlib import Path
          import boto3
          from botocore.config import Config
          import requests

          SUPABASE_URL = "https://anmgyxhnyhbyxzpjhxgx.supabase.co"
          SUPABASE_KEY = os.environ['SUPABASE_KEY']
          R2_ACCOUNT_ID = os.environ['R2_ACCOUNT_ID']
          R2_ACCESS_KEY = os.environ['R2_ACCESS_KEY']
          R2_SECRET_KEY = os.environ['R2_SECRET_KEY']
          R2_BUCKET = 'voyo-audio'
          OFFSET = int(os.environ['OFFSET'])
          LIMIT = int(os.environ['LIMIT'])
          WORKER = os.environ['WORKER']

          TEMP_DIR = Path("/tmp/voyo-audio")
          TEMP_DIR.mkdir(exist_ok=True)

          r2 = boto3.client('s3',
              endpoint_url=f'https://{R2_ACCOUNT_ID}.r2.cloudflarestorage.com',
              aws_access_key_id=R2_ACCESS_KEY,
              aws_secret_access_key=R2_SECRET_KEY,
              config=Config(retries={'max_attempts': 3}))

          def log(msg):
              print(f"[dashgn0026-W{WORKER}] {msg}", flush=True)

          def get_tracks():
              headers = {"apikey": SUPABASE_KEY, "Authorization": f"Bearer {SUPABASE_KEY}"}
              all_tracks = []
              current_offset = OFFSET
              remaining = LIMIT
              while remaining > 0:
                  batch_size = min(1000, remaining)
                  url = f"{SUPABASE_URL}/rest/v1/video_intelligence?select=youtube_id&limit={batch_size}&offset={current_offset}"
                  resp = requests.get(url, headers=headers, timeout=60)
                  resp.raise_for_status()
                  batch = [t['youtube_id'] for t in resp.json() if t.get('youtube_id')]
                  if not batch:
                      break
                  all_tracks.extend(batch)
                  current_offset += len(batch)
                  remaining -= len(batch)
              return all_tracks

          def get_existing():
              existing = set()
              try:
                  paginator = r2.get_paginator('list_objects_v2')
                  for page in paginator.paginate(Bucket=R2_BUCKET, Prefix="128/"):
                      for obj in page.get('Contents', []):
                          key = obj['Key']
                          if '/' in key:
                              filename = key.split('/')[-1]
                              if '.' in filename:
                                  existing.add(filename.rsplit('.', 1)[0])
              except Exception as e:
                  log(f"Warning getting existing: {e}")
              return existing

          def download_and_upload(yt_id, debug=False):
              output = TEMP_DIR / f"{yt_id}.opus"
              cmd = ["yt-dlp", "-x", "--audio-format", "opus", "--audio-quality", "5",
                  "-o", str(TEMP_DIR / f"{yt_id}.%(ext)s"),
                  "--no-playlist",
                  "--cookies", "/tmp/cookies.txt",
                  "--retries", "2", "--socket-timeout", "30",
                  f"https://www.youtube.com/watch?v={yt_id}"]
              try:
                  result = subprocess.run(cmd, capture_output=True, timeout=120, text=True)
                  if debug or result.returncode != 0:
                      log(f"yt-dlp exit={result.returncode} stderr={result.stderr[:200] if result.stderr else 'none'}")
                  if not output.exists():
                      webm = TEMP_DIR / f"{yt_id}.webm"
                      if webm.exists():
                          webm.rename(output)
                  if output.exists():
                      r2.upload_file(str(output), R2_BUCKET, f"128/{yt_id}.opus")
                      output.unlink()
                      return True
              except Exception as e:
                  log(f"Exception for {yt_id}: {e}")
              return False

          def main():
              log(f"Starting: offset={OFFSET}, limit={LIMIT}")
              tracks = get_tracks()
              log(f"Got {len(tracks)} tracks from DB")

              existing = get_existing()
              log(f"Found {len(existing)} already on R2")

              to_process = [t for t in tracks if t not in existing]
              log(f"Need to process: {len(to_process)}")

              if not to_process:
                  log("Nothing to process!")
                  return

              uploaded = 0
              failed = 0

              for i, yt_id in enumerate(to_process):
                  time.sleep(random.uniform(0.1, 0.3))
                  if download_and_upload(yt_id, debug=(i < 3)):
                      uploaded += 1
                  else:
                      failed += 1
                  if (i + 1) % 25 == 0:
                      log(f"Progress: {i+1}/{len(to_process)} | {uploaded} | {failed}")

              log(f"DONE: {uploaded} | {failed}")

          if __name__ == "__main__":
              main()
          SCRIPT

      - name: Run worker
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_KEY }}
          R2_ACCOUNT_ID: ${{ secrets.R2_ACCOUNT_ID }}
          R2_ACCESS_KEY: ${{ secrets.R2_ACCESS_KEY }}
          R2_SECRET_KEY: ${{ secrets.R2_SECRET_KEY }}
          OFFSET: ${{ inputs.start_offset }}
          LIMIT: ${{ inputs.chunk_size }}
          WORKER: ${{ matrix.worker }}
        run: |
          REAL_OFFSET=$(( ${{ inputs.start_offset }} + ${{ matrix.worker }} * ${{ inputs.chunk_size }} ))
          OFFSET=$REAL_OFFSET python worker.py
